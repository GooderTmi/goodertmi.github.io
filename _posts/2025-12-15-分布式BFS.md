---
layout: post          # 布局（固定为 post，主题会自动套用文章模板）
title: "分布式BFS"  # 文章标题（会显示在列表和详情页）
date: 2025-12-15 00:00:00  # 发布时间（和文件名日期一致，精确到分钟）
categories: 技术（杂）      # 分类（可选，用于归档）
tags: [分布式算法]   # 标签（可选，多个用逗号分隔）
---

## 什么是分布式？

之前我们接触到的最短路问题都是在同步网络上进行的。同步网络是指有一个统一的时钟，所有节点时间完全同步，节点行为节奏统一，消息延迟时间可预测，比如我们就可以规定每次从一个节点出发经过一条边找下个节点的时间一直是1。

而异步网络是指各个设备（节点）都有一个各自的时钟，互相未对准，消息延迟时间不可预测，每个节点自身有事情要并发处理，所以可能一次访问经过10条边到终点的时间甚至比经过2条边到同一个终点的时间更短。而且既然没有全局时钟，我们就无法像往常一样建立队列等全局数据结构来进行最短路搜索。

相较于同步网络，分布式架构（异步网络）具有低成本、低复杂度、高健壮性及灵活性优势，被广泛应用于 Web 服务器，实时通讯等方面。

对于这样的网络，求出对于一个源点的最短路树显然是很重要的问题，我们可以知道消息转发在路上花费时间是多少，从而进行合理的规划。

今天我们只讨论所有边权为1的最短路树问题，即BFS树。它也可以称为**分布式广度优先搜索树构建问题**，接下来我将介绍4种算法，逐渐逼近理论下界：时间复杂度 $\Omega(D)$，通信复杂度 $\Omega(E)$ 。

## 简单分布式 BFS 算法

算法1：

- 一轮拓展：首先由源节点发出拓展 $l+1$ 层信号，在 $1$ 至 $l-1$ 层的节点直接向子节点传递即可，到了 $l$ 层节点，比如 $x$ ，需要遍历它所连的边，如果是一个未访问的新节点，那返回“确认”信号， $x$ 就会将其添加到自己的子节点列表，而如果是一个已访问的新节点，则返回“否认”信号，当 $x$ 收到所有连向新节点的边返回的信号的时候，则向父节点返回信号（此信号需包含是否有新节点加入），浅层节点亦是同理。当源节点收到所有子节点返回的信号的时候，它就知道应该启动下一轮拓展（或者停止）了。


这种算法的时间复杂度是 $O(D^2)$ ，通信复杂度 $O(VD+E)$ 。

## 距离缩减范式
若网络直径为 D，可将网络概念性地 “分割” 为 D/d 个长度为 d 的 “条带”。此时，我们的单源问题将转换为多源问题，树也变成了森林，而异步网络中的多源问题由于没有统一时钟，可能会造成混乱，比如一个节点错被加入不该在的树，它可能在某个未知时刻被通知要换树。

算法2：
- 我们考虑朴素地处理，其实换树次数是 $O(d)$ 的，那么直接像 SPFA 一样若有更浅深度出现则更新，这样的复杂度已经可以做到 $O(V\sqrt{E})$ 。因为树边上的全局广播信息数是 $O(\frac{V^2}{d})$ ，条带内部，每条边最多传 $O(d)$ 次通知换树的信息，令 $d=\sqrt{\frac{V^2}{E}}$ 取得最小值。

接下来我们将介绍一个由巴鲁赫和罗伯特于1987年发明的算法，它沿用了上述想法， $d=V^{0.2}$ ，时间和通信复杂度分别是 $O(V^{1.6})$ 和 $O(V^{1.6}+E)$ 。
    
巴鲁赫和罗伯特所采取的解决混乱问题的方法是，将节点分为“大"“小”，分别对应度数 $>V^{0.4}$ 和 $< V^{0.4}$ ；将森林中的树分为“活跃”、“非活跃”、“冻结”，分别对应有 $d$ 层节点可以继续拓展，无 $d$ 层节点可以继续拓展，拓展过程中遇到了“大”节点。

算法3：
- 算法的基本流程是：源节点每次会同步广播条带上的“次源”节点，让它们分别使用简单分布式 BFS 算法去拓展 $d$ 层节点，一开始都是“活跃”树，若遇到“大”点则转为“冻结”，若没得继续拓展则转为“非活跃”，完成了就把自己的状态信息向上返回，最终交给源节点汇总；在这个过程之中，对于一个节点发现一个较浅的节点探索了它，它就会向原父节点告知，并换树（讨论）；在这个过程之后，对于一个条带如果还存在“冻结”树，每次重启会让所有树从最浅的冻结“大”点所在层开始向下拓展；做完上述流程，若“活跃”树只有 $<V^{0.2}$ 个，那么直接继续拓展，总共拓展 $d^2$ 层节点而非 $d$ 层。

- 复杂度简略证明：
  - 对于一次条带拓展，若“活跃”树只有 $<V^{0.2}$ 个，最后若有“活跃”树，里面必然有 $>V^{0.4}$ 个节点；若有$>V^{0.2}$ 个，我们拓展了 $V^{0.2}$ 次，总共有 $>V^{0.4}$ 个节点——所以条带数只会有 $V^{0.6}+1$ 个。还需要关注条带的全局广播数，设有“大”点的层数为 $F$ ，则 $FV^{0.4}\le 3V$ 。综上，全局广播次数是 $O(V^{0.6})$ 的，消息数是 $O(V^{1.6})$。
  - 统计条带内部的消息次数，我们将其分为三类：一是换树时的通知，二是树上的传递，三是探索的传递。对于第一类，首先换树只会发生 $O(V^{0.2})$ 次，对于“大”点由于冻结机制，每条边只会转发一次一类消息，对于小点，每条边（总数 $O(V^{0.4})$ ）可能转发 $O(V^{0.2})$ 条（因为后辈节点可能要给它转发）。对于第二类，我们知道一个点只会换 $O(V^{0.2})$ 次，每次加入至多 $O(V^{0.4})$ 轮。对于第三类直接 $O(E)$ 。综上，这部分是 $O(V^{1.6}+E)$ 的通信复杂度。
  - 消息穿行数即时间复杂度是 $O(V^{1.6})$ 。

## DBFS
Makki 在 1996 年发明了一个通信复杂度为 $O(E)$ 的算法，他主要利用了"平均叶节点高度(alh)"的机制，让更快的通路降速，直至慢速通路的信息到达，并结合其他机制使通信复杂度降至 $O(E)$ 。

限于个人理解深度和讲解时间，我们今天只探讨大概的算法流程。

算法4：
- 首先，从根节点开始，并行向邻居节点发送 EXPLORE 消息（除父节点），若第一次收到 EXPLORE 消息，则设置自己的深度为对应父节点+1。显然，一个节点可能在设置过深度后收到深度更浅的 EXPLORE 信息，此时要重新设置深度和父节点，以及冲突状态（此时该节点会停止继续探索），并且向旧父节点发送 RETURN 信号（这个信号包含了可以用于更新当前节点深度的信息），此信号在叶节点和搜索到更浅节点时也会产生。这样知道每个节点都已经收到所有 RETURN 消息后，第一次迭代就结束了，我们初步建立出 BFS 树。
- 令 alh 为所有冲突状态节点和真叶子的深度平均值。
- 接下来由根节点发出 GEXPLORE 消息，沿着那些未稳定的分支向下传播，最深到达 alh 深度，当它们遇到一个深度遭到改变的节点时，以它们为源节点发送 ADJUSTMENT 和 REEXPLORE 信号使受到影响的后辈节点重新确定深度和父节点。这部分中有类似第一阶段的 RETURN 机制。若某轮结束之后，根节点收到的 RETURN 信息表示，没有处于冲突状态的节点了（此时也必然所有点都遍历过），那么结束。

## 总结

![](https://img.feria.eu.org/qmr8cw.png)

## 参考文献
[1] B. Awerbuch and R. Gallagher, A new distributed algorithm to find Breadth-First Search tree. IEEE Trans. Info. Theory 33 (1987) 315-322.
    
[2] B. Awerbuch, Distributed shortest paths algorithms. Proc. 21st Annual ACM Symposium on Theory of Computing (STOC), 1989, pp. 490-500.

[3] S.A.M Makki, Efficient distributed breadth-first search algorithm. Computer Communications, 1996, Pages 628-636

[4] Victor van der Veen, Faculty of Computer Science, Vrije Universiteit Amsterdam, A Scrutiny of Frederickson’s Distributed Breadth-First Search Algorithm. vvdveen.com/publications, 2008.